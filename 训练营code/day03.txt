if 判断表达式1:
	执行语句1
elif 判断表达式2:
	执行语句2
...
else:
	执行语句3

if 嵌套
if 判断表达式1：
	if 判断表达式2：
		执行语句2
	else:
		执行语句3
else:
	执行语句4




字符串 str
"abc" + "123"   "abc123"
"ab" * 3  "ababab"

s="abcdef"
len(s)  #6

> < >=  <= != 

ascii 编码

0-9  --> 48-57
A-Z  --> 65-90
a-z  --> 97-122

字符串比较则先把字符转换成对应的ascii编码值进行比较
规则：
先比较字符串中第一个字符，如果第一个字符比较出大小
则大的大，小的小，如果第一个相等，则按照规则继续比较第二个字符
"ab"  < "aba"

ord('单个字符') 返回字符所对应的ASCII编码的数字
chr(数字) 返回数字所对应的ASCII编码上的字符


字符串的 索引
语法：序列[整数值]
索引是访问序列的一种方式
分正向索引和反向索引
正向索引从0开始，依次加1,最后一个索引是len(s)-1
反向索引从-1开始，从右到左，依次加-1，
最后一个是-len(s)


s="abcdef"    len(s)  6
  a  b  c  d  e  f
  0  1  2  3  4  5
 -6 -5 -4 -3 -2 -1

‘b’  s[1]   s[-5]


切片
语法:字符串[开始索引:结束索引:步长(以多少长度为截取单位)]
包含开始，不包含结束
步长为正:步长为1则可以省略不写,开始索引为0则可以省略不写
从开始索引的左边开始下刀切取，从结束索引的左边下刀切取结束
步长为正，如果要切取到值则必须开始索引小于结束索引




s="abcdef"    len(s)  6
  a  b  c  d  e  f
  0  1  2  3  4  5
 -6 -5 -4 -3 -2 -1

'ce'  s[2:5:2] 
'ad'  s[0:4:3]   --->s[:4:3]
'bcde' s[1:5:1] ---> s[1:5]

s[-5:-2:2] ---> s[1:4:2]  'bd'
s[2:2:1]  '' 
s[1:100:1]    bcdef

步长为负:
从右到左开始规定范围,切取的字符串组成的与原字符串顺序相反
开始索引为-1的时候可以省略不写，结束索引取得-len(s)后
页可以省略不写，步长不能不写
步长为负，从开始索引的右边开始下刀切，结束索引的右边切结束
步长为负，如果要切取到值，必须开始索引大于结束索引


s="abcdef"    len(s)  6
  a  b  c  d  e  f
  0  1  2  3  4  5
 -6 -5 -4 -3 -2 -1

s[4:3:1]  ''
s[4:3:-1] 'e'
s[5:1:-1]  'fedc'
s[-1:-6:-2]  'fdb'   s[:-6:-2]
s[-2:-7:-1]  'edcba'
s[-2::-1]   'edcba'
s[::-1]   'fedcba'
s[::] 'abcdef'  s[:]


s[1:100:1]    bcdef
s[5:1:-1]  'fedc'


1）求出下来切片的值
s="abcdefjh"
   01234567
'bf'   s[1:6:4]
'dj'   s[3:7:3]
s[0:100:2]  'acej'
s[1:8:2]   'bdfh'

2)a="hello python"
b="隔壁老王"
c="去你家学习"
打印出"hello 去老王家学习python"
print(a[0:6]+c[0]+b[2:]+c[2:]+a[-6:])


序列函数
len() 返回序列的长度,元素的个数
int() 把类整数类型转换成整数类型
float() 把类数字类型转换浮点类型
str() 转换成字符串

max(x) 返回序列x的最大值
min(x) 返回序列x的最小值



整数转字符串函数
bin(x) 把整数转换成二进制字符串
hex(x) 把整数转换成十六进制字符串
oct(x) 把整数转换成八进制字符串

二进制  01   3---11   5---101   以0b 开头 
			  11 -->  1*2的1次方+1*2的0次方 --->3	
			3--> ob11  5---> 0b101
十六进制   0x  0-9a-f

八进制   以0o 开头 20 ---> 0o24



字符串常用方法
语法：
	对象.属性
s.islower() 判断字符串字符是否都为小写
返回值是True / False
s.isupper() 判断字符串字符是否都为大写
s.lower()  返回生成的小写字符串
s.upper()  返回生成的大写字符串
s.strip()  返回去掉左右2边空白的字符串
s.find('sub',开始索引,结束索引) 
获取字符串中sub的索引，没有返回-1
s.count('字符',开始索引,结束索引)
获取索引范围内字符的个数
s.replace(old,new) 
将原字符串old 使用new代替，生成一个新的字符串

练习：输入字符串判断是否为回文
回文:上海自来水来自海上,山西运煤车煤运西山

s=input("请输入字符串:")
if s==s[::-1]:
    print("是回文")
else:
    print("不是回文")


上海自来水来自海上
判断是偶数还是奇数
偶数 中间切一刀，左边正向切，是否等于右边反向切
奇数 中间2刀 最中间字符的左边正向切片，右边反向切片
判断是否相等




' '  " "   """ """   '''  ''' 
三引号：相等于注意功能




while 循环
	根据一定的条件重复的执行一条或者多条语句
语法：
while 真值表达式1:
	执行语句1
else:
	执行语句2
执行规则：先进行真值表达式的判断，如果为真则执行语句1
循环判断，直到真值表达式为False，则执行else 结束

else  可以省略不写

例如：
打印1-10的数
n=1
while n<=10:
    print(n)
    n+=1  #n= n+1
else:
    print("结束")

练习1：打印100以内的偶数
n=0
while n<=100:
    print(n)
    n+=2

练习2：打印以下图形
输入n 打印n行*，例如输入：5
*
**
***
****
*****

n= int(input("请输入行数:"))
i=1
while i<=n:
    print(i*"*")
    i+=1


练习3：打印出
1 2 3 4 5
6 7 8 9 10
11 12 13 14 15
16 17 18 19 20

n= 1
while n<=20:
    print(n,end=' ')
    if n%5==0:
        print()
    n+=1

练习4：
一行打印出"ABCDEF....XYZ"
n=ord('A')  #65
while n<=ord('Z'):
    print(chr(n),end=' ')
    n+=1


练习5:
一行打印出"AaBbCcDd....XxYyZz"

n=ord('A')  #65
while n<=ord('Z'):
    print(chr(n),chr(n+32),end='',sep="")
    n+=1


练习6：打印以下图形
输入n 打印n行*，例如输入：5
*****
****
***
**
*

n=int(input("请输入行数:"))
while n>=0:
    print(n*"*")
    n-=1


练习7：打印以下图形
输入n 打印n行*，例如输入：3
  *			1  2空  1*
 ***		2  1空  3*
*****		3  0空  5*	


    *		1  4空  1*
   ***		2  3空  3*
  *****		3  2空  5*
 *******    4  1空  7*
*********   5  0空  9*

(总行数-当前行个) 空格  +  2倍当前行-1  个 *


n=int(input("请输入行数:"))
x=1
while x<=n:
    print((n-x)*" "+(2*x-1)*"*")
    x+=1


作业题：
进行猜数字游戏：
规则：只能猜5次，显示猜大了，猜小了，中奖了
系统给定随机数：
import random
s = random.randint(0, 100)
print(s)   # 100内的随机数


拓展：只要猜对直接结束(思考)


















